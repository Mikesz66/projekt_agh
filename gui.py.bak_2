import sys
import pprint
import json
import os
import time
from typing import List, Optional

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from PySide6.QtCore import (
    Qt,
    QRect,
    QSize,
    QPoint,
    QTimer,
    Signal,
    QObject,
)
from PySide6.QtWidgets import (
    QApplication,
    QHBoxLayout,
    QLayout,
    QLayoutItem,
    QLabel,
    QLineEdit,
    QPushButton,
    QScrollArea,
    QSizePolicy,
    QStyle,
    QVBoxLayout,
    QWidget,
)

from paths import RECIPES_FOUND


class FlowLayout(QLayout):
    def __init__(self, parent: Optional[QWidget] = None, margin: int = 0, h_spacing: int = -1, v_spacing: int = -1):
        super().__init__(parent)
        self._item_list: List[QLayoutItem] = []
        self._h_space = h_spacing
        self._v_space = v_spacing
        self.setContentsMargins(margin, margin, margin, margin)

    def __del__(self):
        item = self.takeAt(0)
        while item:
            item = self.takeAt(0)

    def addItem(self, item: QLayoutItem):
        self._item_list.append(item)

    def count(self) -> int:
        return len(self._item_list)

    def itemAt(self, index: int) -> Optional[QLayoutItem]:
        if 0 <= index < len(self._item_list):
            return self._item_list[index]
        return None

    def takeAt(self, index: int) -> Optional[QLayoutItem]:
        if 0 <= index < len(self._item_list):
            return self._item_list.pop(index)
        return None

    def expandingDirections(self) -> Qt.Orientation:
        return Qt.Orientation(0)

    def hasHeightForWidth(self) -> bool:
        return True

    def heightForWidth(self, width: int) -> int:
        return self._do_layout(QRect(0, 0, width, 0), True)

    def setGeometry(self, rect: QRect):
        super().setGeometry(rect)
        self._do_layout(rect, False)

    def sizeHint(self) -> QSize:
        return self.minimumSize()

    def minimumSize(self) -> QSize:
        size = QSize()
        for item in self._item_list:
            size = size.expandedTo(item.minimumSize())
        margins = self.contentsMargins()
        size += QSize(margins.left() + margins.right(), margins.top() + margins.bottom())
        return size

    def getWidgets(self) -> List[QWidget]:
        widgets = []
        for item in self._item_list:
            widget = item.widget()
            if widget:
                widgets.append(widget)
        return widgets

    def horizontalSpacing(self) -> int:
        if self._h_space >= 0: return self._h_space
        return self.smartSpacing(QStyle.PM_LayoutHorizontalSpacing)

    def verticalSpacing(self) -> int:
        if self._v_space >= 0: return self._v_space
        return self.smartSpacing(QStyle.PM_LayoutVerticalSpacing)

    def smartSpacing(self, pm: QStyle.PixelMetric) -> int:
        parent = self.parent()
        if not parent: return -1
        if parent.isWidgetType():
            return parent.style().pixelMetric(pm, None, parent)
        return QApplication.style().pixelMetric(pm, None, None)

    def _do_layout(self, rect: QRect, test_only: bool) -> int:
        left, top, right, bottom = self.getContentsMargins()
        effective_rect = rect.adjusted(+left, +top, -right, -bottom)
        x = effective_rect.x()
        y = effective_rect.y()
        line_height = 0
        spacing_x = self.horizontalSpacing()
        spacing_y = self.verticalSpacing()
        if spacing_x == -1: spacing_x = 10
        if spacing_y == -1: spacing_y = 10

        for item in self._item_list:
            next_x = x + item.sizeHint().width() + spacing_x
            if next_x - spacing_x > effective_rect.right() and line_height > 0:
                x = effective_rect.x()
                y = y + line_height + spacing_y
                next_x = x + item.sizeHint().width() + spacing_x
                line_height = 0
            if not test_only:
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))
            x = next_x
            line_height = max(line_height, item.sizeHint().height())
        return y + line_height - rect.y() + top + bottom
class FlowScrollArea(QScrollArea):
    """
    A QScrollArea that automatically contains a widget with a FlowLayout.
    It proxies the FlowLayout API methods.
    """
    def __init__(self, height: Optional[int] = 50, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self._container = QWidget()
        self._container.setObjectName("flowContainer")
        self._flow_layout = FlowLayout(self._container)
        self.setWidget(self._container)
        self.setWidgetResizable(True)
        self.setFrameShape(QScrollArea.NoFrame)
        if height is not None:
            self.setFixedHeight(height)

        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Maximum)
        self.updateGeometry()

    def addWidget(self, widget: QWidget):
        """Adds a widget to the internal FlowLayout."""
        self._flow_layout.addWidget(widget)

    def getWidgets(self) -> List[QWidget]:
        """Returns the list of widgets in the internal FlowLayout."""
        return self._flow_layout.getWidgets()

    def removeWidget(self, widget: QWidget):
        """Removes a widget from the internal layout."""
        self._flow_layout.removeWidget(widget)
        widget.deleteLater()

    def clear(self):
        """Removes all widgets."""
        item = self._flow_layout.takeAt(0)
        while item:
            if item.widget():
                item.widget().deleteLater()
            item = self._flow_layout.takeAt(0)

    def setSpacing(self, h_spacing: int, v_spacing: int):
        """Sets horizontal and vertical spacing."""
        self._flow_layout._h_space = h_spacing
        self._flow_layout._v_space = v_spacing
        self._flow_layout.update()

    def setContentsMargins(self, left: int, top: int, right: int, bottom: int):
        """Sets margins on the INTERNAL layout, not the scroll area frame."""
        self._flow_layout.setContentsMargins(left, top, right, bottom)

    def sizeHint(self) -> QSize:
        """Tell the parent layout (left_menu) to respect the inner content height."""
        inner_size = self._container.sizeHint()
        height = inner_size.height() + self.frameWidth() * 2
        return QSize(super().sizeHint().width(), height)
class Storage:
    def __init__(self) -> None:
        self._subscribers: list[tuple[str, object]] = []

    def add(self, key_name:str, object_instance:object):
        new_entry: tuple[str, object] = (key_name, object_instance)
        self._subscribers.append(new_entry)

    def _objects_to_dict(self) -> dict[str, str | list[str]]:
        def _object_to_data(object_instance: object) -> str | list[str]:
            if hasattr(object_instance, "text"):
                return object_instance.text() # type: ignore
            match object_instance:
                case str():
                    return object_instance
                case int():
                    return str(object_instance)
                case FlowScrollArea():
                    items = []
                    widgets = object_instance.getWidgets()
                    for widget in widgets:
                        item = _object_to_data(widget)
                        if not item or item == "":
                            continue
                        items.append(item)
                    return items
                case _:
                    return ""

        output:dict[str, str | list[str]] = {}
        for pair in self._subscribers:
            key_name, object_instance = pair
            widget_contents = _object_to_data(object_instance)
            if not widget_contents or widget_contents == "" or widget_contents == []:
                continue
            if not key_name or key_name == "":
                print("WARNING: Passed a empty key_name for contents", f"'{widget_contents}'")
                continue
            output[key_name] = widget_contents
        return output

    def get_data(self) -> dict[str, str | list[str]]:
        return self._objects_to_dict()

storage = Storage()

class RecipeFileHandler(QObject, FileSystemEventHandler):
    """
    Monitors file system events (Create, Modify, Delete, Move) 
    and emits a signal when the target file is affected.
    """
    file_changed = Signal()

    def __init__(self, target_filename):
        super().__init__()
        self.target_filename = target_filename

    def _process_event(self, event):
        # Check if the event involves our target file
        # For 'moved', dest_path might be the target
        is_target = False
        if hasattr(event, 'dest_path'):
            if os.path.basename(event.dest_path) == self.target_filename:
                is_target = True
        
        if os.path.basename(event.src_path) == self.target_filename:
            is_target = True

        if is_target:
            self.file_changed.emit()

    def on_modified(self, event):
        self._process_event(event)

    def on_created(self, event):
        self._process_event(event)

    def on_deleted(self, event):
        self._process_event(event)

    def on_moved(self, event):
        self._process_event(event)

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("PyQt6 Stylesheet Example")
        self.setGeometry(100, 100, 800, 500)
        self.setObjectName("mainWindow")

        self._ui()
        
        # Initialize Watchdog and Debounce Timer
        self._setup_file_watcher()
        
        # Try to load initially if file exists
        self.reload_results_from_file()

    def _ui(self):
        layout = QHBoxLayout()

        # Left
        left_menu = QVBoxLayout()
        search_button = QPushButton("Search")
        search_button.clicked.connect(self.on_search_press)
        left_menu.addWidget(self._ui_app_title())
        left_menu.addWidget(self._ui_scrollable_menu())
        left_menu.addWidget(search_button)

        # Right
        right_decoration = QWidget()
        # We save this to self so we can add/remove widgets later
        self.right_menu_layout = QVBoxLayout(right_decoration)
        
        # Add a stretch initially so if empty, space is preserved
        self.right_menu_layout.addStretch()

        # Center
        layout.addLayout(left_menu)
        layout.addWidget(right_decoration)
        
        # Adjust stretch factors: Left takes 1 part, Right takes 2 parts
        layout.setStretch(0, 1)
        layout.setStretch(1, 2)
        
        self.setLayout(layout)
        return

    def _ui_app_title(self) -> QWidget:
        app_title_widget = QWidget()
        app_title = QVBoxLayout(app_title_widget)
        app_title.addWidget(QLabel("Wyszukiwarka"))
        app_title.addWidget(QLabel("Przepisów"))
        app_title_widget.setSizePolicy(
            QSizePolicy.Policy.Fixed,
            QSizePolicy.Policy.Fixed
        )
        return app_title_widget

    def _ui_scrollable_menu(self) -> QScrollArea:
        content_widget = QWidget()
        filter_menu = QVBoxLayout(content_widget)

        filter_menu.addWidget(self._ui_recipe_name())
        filter_menu.addWidget(self._ui_liked_box())
        filter_menu.addWidget(self._ui_disliked_box())

        filter_menu.addStretch()

        scrollable_menu = QScrollArea()
        scrollable_menu.setWidget(content_widget)
        scrollable_menu.setWidgetResizable(True)
        scrollable_menu.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scrollable_menu.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scrollable_menu.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        return scrollable_menu

    def _ui_recipe_name(self) -> QWidget:
        output_widget = QWidget()
        layout = QVBoxLayout(output_widget)
        label = QLabel("Nazwa Przepisu")
        line_edit = QLineEdit()
        storage.add("recipe_name",line_edit)

        layout.addWidget(label)
        layout.addWidget(line_edit)

        return output_widget

    def _ui_liked_box(self) -> QWidget:
        output_widget = QWidget()
        layout = QVBoxLayout(output_widget)
        label = QLabel("Składniki Lubiane")
        line_edit = QLineEdit()
        flexbox = FlowScrollArea()
        storage.add("liked_recipes",flexbox)
        flexbox.addWidget(QPushButton("TEST"))
        flexbox.addWidget(QPushButton("TEST"))
        flexbox.addWidget(QPushButton("TEST"))
        
        layout.addWidget(label)
        layout.addWidget(line_edit)
        layout.addWidget(flexbox)

        return output_widget

    def _ui_disliked_box(self) -> QWidget:
        output_widget = QWidget()
        layout = QVBoxLayout(output_widget)
        label = QLabel("Składniki Nielubiane")
        line_edit = QLineEdit()
        flexbox = FlowScrollArea()
        storage.add("disiked_recipes",flexbox)
        flexbox.addWidget(QPushButton("TEST"))
        flexbox.addWidget(QPushButton("TEST"))
        
        layout.addWidget(label)
        layout.addWidget(line_edit)
        layout.addWidget(flexbox)

        return output_widget

    def on_search_press(self):
        # Does nothing as requested
        pass

    def _setup_file_watcher(self):
        # 1. Setup Debounce Timer
        self.debounce_timer = QTimer()
        self.debounce_timer.setSingleShot(True)
        self.debounce_timer.setInterval(200) # 200ms delay
        self.debounce_timer.timeout.connect(self.reload_results_from_file)

        # 2. Setup Watchdog
        # Ensure directory exists or handle error, here we assume paths are valid
        folder = os.path.dirname(RECIPES_FOUND)
        filename = os.path.basename(RECIPES_FOUND)

        if not os.path.exists(folder):
            print(f"Warning: Folder {folder} does not exist. Watcher might fail.")
            return

        self.event_handler = RecipeFileHandler(filename)
        self.event_handler.file_changed.connect(self.on_file_change_signal)

        self.observer = Observer()
        self.observer.schedule(self.event_handler, folder, recursive=False)
        self.observer.start()

    def closeEvent(self, event):
        """Clean up observer thread on app exit"""
        if hasattr(self, 'observer'):
            self.observer.stop()
            self.observer.join()
        event.accept()

    def on_file_change_signal(self):
        """Called when file changes. Resets the timer (Debouncing)."""
        self.debounce_timer.start()

    def reload_results_from_file(self):
        """Reads file, validates structure, and updates UI."""
        # 1. Handle File Missing / Deleted
        if not os.path.exists(RECIPES_FOUND):
            self._show_placeholder("File not found. Waiting for recipes...")
            return

        try:
            with open(RECIPES_FOUND, 'r') as f:
                # Handle empty file case (e.g. created but not written yet)
                content = f.read().strip()
                if not content:
                    self._show_placeholder("File is empty...")
                    return 
                data = json.loads(content)

            # Validate top-level structure is a list
            if not isinstance(data, list):
                self._show_placeholder("Invalid data format: Expected a List")
                return

            self.populate_results(data)

        except json.JSONDecodeError:
            # Common during write operations
            pass 
        except Exception as e:
            print(f"Error reading file: {e}")
            self._show_placeholder(f"Error reading file: {e}")

    def populate_results(self, results: list):
        """Filters valid entries and displays them."""
        self._clear_right_menu()

        valid_items_count = 0

        for data in results:
            # Validate individual item structure
            if not isinstance(data, dict):
                continue
            if "id" not in data or "accuracy" not in data:
                continue

            # Create and add widget
            widget = self._create_result_widget(data)
            self.right_menu_layout.addWidget(widget)
            valid_items_count += 1
        
        if valid_items_count == 0:
            self._show_placeholder("No valid recipes found")
        else:
            self.right_menu_layout.addStretch()

    def _show_placeholder(self, message: str):
        """Helper to show a gray placeholder text in the right menu."""
        self._clear_right_menu()
        
        label = QLabel(message)
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        label.setStyleSheet("color: #888888; font-size: 16px; padding: 20px;")
        
        self.right_menu_layout.addWidget(label)
        self.right_menu_layout.addStretch()

    def _clear_right_menu(self):
        """Removes all widgets from the right menu layout."""
        while self.right_menu_layout.count():
            item = self.right_menu_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

    def _create_result_widget(self, data: dict) -> QWidget:
        card = QWidget()
        card.setObjectName("resultCard")
        
        # Basic styling
        card.setStyleSheet("""
            QWidget#resultCard {
                background-color: #f0f0f0; 
                border: 1px solid #c0c0c0; 
                border-radius: 8px;
            }
            QLabel { font-size: 14px; }
        """)
        
        layout = QVBoxLayout(card)
        
        r_id = data.get("id", "Unknown")
        acc_raw = data.get("accuracy", 0.0)
        acc_percent = f"{acc_raw * 100:.1f}%"

        id_label = QLabel(f"<b>Recipe ID:</b> {r_id}")
        acc_label = QLabel(f"Match: {acc_percent}")
        
        if acc_raw > 0.9:
            acc_label.setStyleSheet("color: green; font-weight: bold;")
        elif acc_raw > 0.6:
            acc_label.setStyleSheet("color: orange;")
        else:
            acc_label.setStyleSheet("color: red;")

        layout.addWidget(id_label)
        layout.addWidget(acc_label)
        
        return card


def get_stylesheet() -> str:
    try:
        with open("styles.css", "r") as f:
            stylesheet = f.read()
            return stylesheet
    except FileNotFoundError:
        print("Stylesheet 'styles.css' not found. Using default styles.")
        return ""
def test_vertical_group() -> QWidget:
    new_widget = QWidget()
    new_widget.setObjectName("test")
    return new_widget
def vertical_group() -> QWidget:
    new_widget = QWidget()
    new_widget.setObjectName("test")
    return new_widget

def main():
    app = QApplication(sys.argv)
    app.setStyleSheet(get_stylesheet())
    window = MainWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
